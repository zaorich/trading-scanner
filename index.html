<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>风暴之眼 - 多周期交易机会扫描器 (Pro)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .performance-badge {
            display: inline-block;
            background: linear-gradient(45deg, #00d4aa, #00b894);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
        }
        
        .timeframe-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .timeframe-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .timeframe-btn.active {
            background: #4ecdc4;
            color: #fff;
        }
        
        .timeframe-btn:not(.active) {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        
        .scan-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .batch-size-selector {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #aaa;
            font-size: 0.9em;
        }
        
        .batch-size-selector select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
        }
        
        .scan-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        .scan-btn:hover {
            transform: scale(1.05);
        }
        
        .fresh-scan-btn {
            background: linear-gradient(45deg, #9b59b6, #8e44ad) !important;
            border-left: 2px solid rgba(255,255,255,0.2);
            margin-left: 0;
            position: relative;
        }
        
        .fresh-scan-btn:hover {
            background: linear-gradient(45deg, #8e44ad, #9b59b6) !important;
            transform: scale(1.05);
        }
        
        .scan-btn:disabled {
            opacity: 0.6;
            transform: none;
            cursor: not-allowed;
        }
        
        .status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
            min-height: 30px;
        }
        
        .progress-container {
            margin: 10px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #aaa;
        }
        
        .timeframe-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.05);
            padding: 5px;
            border-radius: 10px;
        }
        
        .tab-btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #aaa;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .tab-btn.active {
            background: #4ecdc4;
            color: #fff;
        }
        
        .tab-btn:hover:not(.active) {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .results-table {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        th {
            background: rgba(255,255,255,0.1);
            font-weight: bold;
            color: #4ecdc4;
        }
        
        tr:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .signal-long {
            color: #00ff88;
            font-weight: bold;
        }
        
        .signal-short {
            color: #ff4757;
            font-weight: bold;
        }
        
        .signal-none {
            color: #666;
        }
        
        .volume {
            font-weight: bold;
            color: #ffa502;
        }
        
        .price-change {
            font-weight: bold;
        }
        
        .positive {
            color: #00ff88;
        }
        
        .negative {
            color: #ff4757;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #4ecdc4;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .filters-passed {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .filter-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .filter-space {
            background: #27ae60;
            color: white;
        }
        
        .filter-quality {
            background: #3498db;
            color: white;
        }
        
        .tcm-bullish {
            color: #00ff88;
            font-weight: bold;
        }
        
        .tcm-bearish {
            color: #ff4757;
            font-weight: bold;
        }
        
        .tcm-neutral {
            color: #666;
        }
        
        .summary {
            display: flex;
            justify-content: space-around;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .summary-item {
            text-align: center;
        }
        
        .summary-number {
            font-size: 2em;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .performance-metrics {
            display: flex;
            justify-content: space-around;
            background: rgba(0, 212, 170, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        
        .metric-item {
            text-align: center;
        }
        
        .metric-value {
            font-weight: bold;
            color: #00d4aa;
        }
        
        .timeframe-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .badge-15m {
            background: #e74c3c;
            color: white;
        }
        
        .badge-1h {
            background: #f39c12;
            color: white;
        }
        
        .badge-4h {
            background: #9b59b6;
            color: white;
        }
        
        .risk-reward-excellent {
            color: #00ff88;
            font-weight: bold;
        }
        
        .risk-reward-good {
            color: #ffa502;
            font-weight: bold;
        }
        
        .risk-reward-poor {
            color: #ff4757;
            font-weight: bold;
        }
        
        .entry-price {
            background: rgba(78, 205, 196, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .stop-loss {
            background: rgba(255, 71, 87, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            color: #ff4757;
        }
        
        .take-profit {
            background: rgba(0, 255, 136, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            color: #00ff88;
        }
        
        .no-opportunities {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🌪️ 风暴之眼多周期扫描器 (Pro)</h1>
            <p>同时扫描15分钟、1小时、4小时三个周期的交易机会</p>
            <div class="performance-badge">⚡ 多周期并行扫描版</div>
        </div>
        
        <div class="controls">
            <div class="timeframe-selector">
                <span style="color: #aaa; margin-right: 10px;">扫描周期:</span>
                <div class="timeframe-badge badge-15m">15分钟 战术级</div>
                <div class="timeframe-badge badge-1h">1小时 波段</div>
                <div class="timeframe-badge badge-4h">4小时 头寸</div>
            </div>
            
            <div class="scan-controls">
                <div class="batch-size-selector">
                    <label>并发数:</label>
                    <select id="batchSize">
                        <option value="5">5</option>
                        <option value="10" selected>10</option>
                        <option value="15">15</option>
                        <option value="20">20</option>
                    </select>
                </div>
                <button class="scan-btn" id="scanBtn">开始多周期扫描</button>
                <button class="scan-btn fresh-scan-btn" id="freshScanBtn">🔄 强制刷新扫描</button>
            </div>
        </div>
        
        <div class="status" id="status">点击"开始多周期扫描"来发现所有周期的交易机会</div>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-stats">
                <span id="progressText">准备就绪</span>
                <span id="progressSpeed"></span>
            </div>
        </div>
        
        <div class="performance-metrics" id="performanceMetrics" style="display: none;">
            <div class="metric-item">
                <div class="metric-value" id="scanTime">0s</div>
                <div>扫描耗时</div>
            </div>
            <div class="metric-item">
                <div class="metric-value" id="avgSpeed">0/s</div>
                <div>平均速度</div>
            </div>
            <div class="metric-item">
                <div class="metric-value" id="successRate">0%</div>
                <div>成功率</div>
            </div>
            <div class="metric-item">
                <div class="metric-value" id="apiCalls">0</div>
                <div>API调用</div>
            </div>
        </div>
        
        <div class="summary" id="summary" style="display: none;">
            <div class="summary-item">
                <div class="summary-number" id="totalScanned">0</div>
                <div>已扫描</div>
            </div>
            <div class="summary-item">
                <div class="summary-number" id="totalOpportunities">0</div>
                <div>总机会数</div>
            </div>
            <div class="summary-item">
                <div class="summary-number" id="longSignals">0</div>
                <div>做多信号</div>
            </div>
            <div class="summary-item">
                <div class="summary-number" id="shortSignals">0</div>
                <div>做空信号</div>
            </div>
        </div>
        
        <div class="timeframe-tabs" id="timeframeTabs" style="display: none;">
            <button class="tab-btn active" data-timeframe="15m">
                15分钟机会 <span id="count15m">(0)</span>
            </button>
            <button class="tab-btn" data-timeframe="1h">
                1小时机会 <span id="count1h">(0)</span>
            </button>
            <button class="tab-btn" data-timeframe="4h">
                4小时机会 <span id="count4h">(0)</span>
            </button>
        </div>
        
        <div id="results15m" class="tab-content active">
            <div class="results-table" style="display: none;">
                <table>
                    <thead>
                        <tr>
                            <th>交易对</th>
                            <th>24h交易额</th>
                            <th>当前价格</th>
                            <th>24h涨跌</th>
                            <th>信号类型</th>
                            <th>战略TCM(4h)</th>
                            <th>战术TCM(1h)</th>
                            <th>执行MACD(15m)</th>
                            <th>入场价位</th>
                            <th>止损位</th>
                            <th>止盈位</th>
                            <th>盈亏比</th>
                            <th>过滤器</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="no-opportunities" style="display: none;">
                暂未发现15分钟周期的交易机会
            </div>
        </div>
        
        <div id="results1h" class="tab-content">
            <div class="results-table" style="display: none;">
                <table>
                    <thead>
                        <tr>
                            <th>交易对</th>
                            <th>24h交易额</th>
                            <th>当前价格</th>
                            <th>24h涨跌</th>
                            <th>信号类型</th>
                            <th>战略TCM(1d)</th>
                            <th>战术TCM(4h)</th>
                            <th>执行MACD(1h)</th>
                            <th>入场价位</th>
                            <th>止损位</th>
                            <th>止盈位</th>
                            <th>盈亏比</th>
                            <th>过滤器</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="no-opportunities" style="display: none;">
                暂未发现1小时周期的交易机会
            </div>
        </div>
        
        <div id="results4h" class="tab-content">
            <div class="results-table" style="display: none;">
                <table>
                    <thead>
                        <tr>
                            <th>交易对</th>
                            <th>24h交易额</th>
                            <th>当前价格</th>
                            <th>24h涨跌</th>
                            <th>信号类型</th>
                            <th>战略TCM(1w)</th>
                            <th>战术TCM(1d)</th>
                            <th>执行MACD(4h)</th>
                            <th>入场价位</th>
                            <th>止损位</th>
                            <th>止盈位</th>
                            <th>盈亏比</th>
                            <th>过滤器</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="no-opportunities" style="display: none;">
                暂未发现4小时周期的交易机会
            </div>
        </div>
    </div>

    <script>
        class TechnicalIndicators {
            static SMA(prices, period) {
                if (prices.length < period) return null;
                const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
                return sum / period;
            }
            
            static EMA(prices, period) {
                if (prices.length < period) return null;
                
                const multiplier = 2 / (period + 1);
                const emaArray = [];
                
                let sma = 0;
                for (let i = 0; i < period; i++) {
                    sma += prices[i];
                }
                sma = sma / period;
                emaArray[period - 1] = sma;
                
                for (let i = period; i < prices.length; i++) {
                    emaArray[i] = (prices[i] * multiplier) + (emaArray[i - 1] * (1 - multiplier));
                }
                
                return emaArray[emaArray.length - 1];
            }
            
            static EMAArray(prices, period) {
                if (prices.length < period) return null;
                
                const multiplier = 2 / (period + 1);
                const emaArray = [];
                
                let sma = 0;
                for (let i = 0; i < period; i++) {
                    sma += prices[i];
                }
                sma = sma / period;
                emaArray[period - 1] = sma;
                
                for (let i = period; i < prices.length; i++) {
                    emaArray[i] = (prices[i] * multiplier) + (emaArray[i - 1] * (1 - multiplier));
                }
                
                return emaArray;
            }
            
            static MACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                if (prices.length < slowPeriod + signalPeriod) return null;
                
                const fastEMAArray = this.EMAArray(prices, fastPeriod);
                const slowEMAArray = this.EMAArray(prices, slowPeriod);
                
                if (!fastEMAArray || !slowEMAArray) return null;
                
                const macdArray = [];
                for (let i = slowPeriod - 1; i < prices.length; i++) {
                    macdArray.push(fastEMAArray[i] - slowEMAArray[i]);
                }
                
                const signalArray = this.EMAArray(macdArray, signalPeriod);
                
                if (!signalArray) return null;
                
                const latestMacd = macdArray[macdArray.length - 1];
                const latestSignal = signalArray[signalArray.length - 1];
                const latestHistogram = latestMacd - latestSignal;
                
                const prevMacd = macdArray.length > 1 ? macdArray[macdArray.length - 2] : latestMacd;
                const prevSignal = signalArray.length > 1 ? signalArray[signalArray.length - 2] : latestSignal;
                
                return {
                    macd: latestMacd,
                    signal: latestSignal,
                    histogram: latestHistogram,
                    prevMacd: prevMacd,
                    prevSignal: prevSignal
                };
            }
            
            static ATR(highs, lows, closes, period = 14) {
                if (highs.length < period || lows.length < period || closes.length < period) {
                    return null;
                }
                
                const trueRanges = [];
                for (let i = 1; i < closes.length; i++) {
                    const tr1 = highs[i] - lows[i];
                    const tr2 = Math.abs(highs[i] - closes[i-1]);
                    const tr3 = Math.abs(lows[i] - closes[i-1]);
                    trueRanges.push(Math.max(tr1, tr2, tr3));
                }
                
                if (trueRanges.length < period) return null;
                
                return this.SMA(trueRanges, period);
            }
        }

        class MultiTimeframeScanner {
            constructor() {
                this.isScanning = false;
                this.symbols = [];
                this.opportunities = {
                    '15m': [],
                    '1h': [],
                    '4h': []
                };
                this.batchSize = 10;
                this.startTime = 0;
                this.processedCount = 0;
                this.successCount = 0;
                this.apiCallCount = 0;
                this.activeTimeframe = '15m';
                this.useCache = true;
                
                this.requestCache = new Map();
                
                this.moduleConfigs = {
                    '15m': {
                        name: '15分钟战术级交易',
                        execution: '15m',
                        tactical: '1h', 
                        strategic: '4h',
                        smaShort: 60,
                        smaLongExecution: 240,
                        smaLongTactical: 240,
                        smaLongStrategic: 360
                    },
                    '1h': {
                        name: '1小时波段交易',
                        execution: '1h',
                        tactical: '4h',
                        strategic: '1d',
                        smaShort: 60,
                        smaLongExecution: 240,
                        smaLongTactical: 360,
                        smaLongStrategic: 300
                    },
                    '4h': {
                        name: '4小时头寸交易',
                        execution: '4h',
                        tactical: '1d',
                        strategic: '1w',
                        smaShort: 60,
                        smaLongExecution: 360,
                        smaLongTactical: 300,
                        smaLongStrategic: 260
                    }
                };
                
                this.initializeEvents();
            }
            
            initializeEvents() {
                document.getElementById('batchSize').addEventListener('change', (e) => {
                    this.batchSize = parseInt(e.target.value);
                });
                
                document.getElementById('scanBtn').addEventListener('click', () => {
                    this.startMultiTimeframeScan(true);
                });
                
                document.getElementById('freshScanBtn').addEventListener('click', () => {
                    this.startMultiTimeframeScan(false);
                });
                
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const timeframe = e.currentTarget.dataset.timeframe;
                        this.switchTimeframe(timeframe);
                    });
                });
            }
            
            switchTimeframe(timeframe) {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-timeframe="${timeframe}"]`).classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`results${timeframe}`).classList.add('active');
                
                this.activeTimeframe = timeframe;
            }
            
            async startMultiTimeframeScan(useCache = true) {
                if (this.isScanning) return;
                
                this.isScanning = true;
                this.useCache = useCache;
                this.startTime = Date.now();
                this.processedCount = 0;
                this.successCount = 0;
                this.apiCallCount = 0;
                
                const scanBtn = document.getElementById('scanBtn');
                const freshScanBtn = document.getElementById('freshScanBtn');
                const status = document.getElementById('status');
                
                scanBtn.disabled = true;
                freshScanBtn.disabled = true;
                
                if (useCache) {
                    scanBtn.innerHTML = '<span class="loading"></span> 多周期扫描中...';
                    status.innerHTML = '正在扫描交易机会（使用缓存数据）...';
                } else {
                    freshScanBtn.innerHTML = '<span class="loading"></span> 强制刷新中...';
                    status.innerHTML = '正在获取最新数据并扫描交易机会...';
                    this.requestCache.clear();
                }
                
                try {
                    this.opportunities = { '15m': [], '1h': [], '4h': [] };
                    this.hideAllResults();
                    
                    status.innerHTML = useCache ? '正在获取交易对列表...' : '正在获取最新交易对列表...';
                    
                    await this.fetchSymbols();
                    
                    await this.analyzeAllTimeframes();
                    
                    this.displayAllResults();
                    this.updateOverallSummary();
                    this.updatePerformanceMetrics();
                    
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const totalOpportunities = Object.values(this.opportunities).reduce((sum, arr) => sum + arr.length, 0);
                    const cacheStatus = useCache ? '（缓存优化）' : '（最新数据）';
                    status.innerHTML = `扫描完成！在 ${this.symbols.length} 个交易对中发现 ${totalOpportunities} 个潜在机会 ${cacheStatus} (耗时: ${elapsed.toFixed(1)}秒)`;
                    
                    document.getElementById('timeframeTabs').style.display = 'flex';
                    
                } catch (error) {
                    console.error('扫描错误:', error);
                    status.innerHTML = '扫描过程中发生错误: ' + error.message;
                } finally {
                    this.isScanning = false;
                    scanBtn.disabled = false;
                    freshScanBtn.disabled = false;
                    scanBtn.innerHTML = '开始多周期扫描';
                    freshScanBtn.innerHTML = '🔄 强制刷新扫描';
                    document.getElementById('progressFill').style.width = '0%';
                }
            }
            
            async fetchSymbols() {
                try {
                    this.apiCallCount++;
                    const response = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
                    if (!response.ok) throw new Error('获取交易对数据失败');
                    
                    const data = await response.json();
                    
                    this.symbols = data
                        .filter(item => item.symbol.endsWith('USDT'))
                        .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                        .slice(0,200);
                        
                } catch (error) {
                    throw new Error('获取交易对列表失败: ' + error.message);
                }
            }
            
            async analyzeAllTimeframes() {
                const batches = this.createBatches(this.symbols, this.batchSize);
                const totalSymbols = this.symbols.length;
                
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    
                    const batchPromises = batch.map(async (symbolData) => {
                        try {
                            const timeframeAnalyses = await this.analyzeSymbolAllTimeframes(symbolData);
                            
                            Object.keys(timeframeAnalyses).forEach(timeframe => {
                                const analysis = timeframeAnalyses[timeframe];
                                if (analysis.hasOpportunity) {
                                    this.opportunities[timeframe].push(analysis);
                                    this.successCount++;
                                }
                            });
                        } catch (error) {
                            console.error(`分析 ${symbolData.symbol} 时出错:`, error);
                        } finally {
                            this.processedCount++;
                        }
                    });
                    
                    await Promise.all(batchPromises);

                    const lastSymbolInBatch = batch[batch.length - 1];
                    if (lastSymbolInBatch) {
                        this.updateProgress((this.processedCount / totalSymbols) * 100, lastSymbolInBatch.symbol, this.processedCount);
                    }

                    if (batchIndex < batches.length - 1) {
                        await this.delay(500);
                    }
                }
                
                Object.keys(this.opportunities).forEach(timeframe => {
                    this.opportunities[timeframe].sort((a, b) => parseFloat(b.volume) - parseFloat(a.volume));
                });
            }
            
            async analyzeSymbolAllTimeframes(symbolData) {
                const symbol = symbolData.symbol;
                const results = {};
                
                const allIntervals = new Set();
                Object.values(this.moduleConfigs).forEach(config => {
                    allIntervals.add(config.execution);
                    allIntervals.add(config.tactical);
                    allIntervals.add(config.strategic);
                });
                
                const klineData = await this.fetchKlineDataParallel(symbol, Array.from(allIntervals));
                
                Object.keys(this.moduleConfigs).forEach(timeframe => {
                    const config = this.moduleConfigs[timeframe];
                    const analysis = this.calculateTechnicalAnalysis(klineData, config);
                    const opportunity = this.evaluateOpportunity(analysis, config);
                    
                    results[timeframe] = {
                        timeframe: timeframe,
                        symbol: symbol,
                        price: parseFloat(symbolData.lastPrice),
                        change24h: parseFloat(symbolData.priceChangePercent),
                        volume: parseFloat(symbolData.quoteVolume),
                        ...opportunity
                    };
                });
                
                return results;
            }
            
            async fetchKlineDataParallel(symbol, intervals) {
                const promises = intervals.map(async (interval) => {
                    const cacheKey = `${symbol}_${interval}`;

                    if (this.useCache && this.requestCache.has(cacheKey)) {
                        return { interval, data: this.requestCache.get(cacheKey) };
                    }
                    
                    try {
                        this.apiCallCount++;
                        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=500`;
                        const response = await fetch(url);
                        
                        if (!response.ok) {
                            throw new Error(`获取 ${symbol} ${interval} K线数据失败 (${response.status})`);
                        }
                        
                        const rawData = await response.json();
                        const processedData = rawData.map(item => ({
                            open: parseFloat(item[1]),
                            high: parseFloat(item[2]),
                            low: parseFloat(item[3]),
                            close: parseFloat(item[4]),
                            volume: parseFloat(item[5])
                        }));
                        
                        this.requestCache.set(cacheKey, processedData);
                        return { interval, data: processedData };
                        
                    } catch (error) {
                        console.error(error.message);
                        return { interval, data: null };
                    }
                });
                
                const results = await Promise.all(promises);
                const klineData = {};
                
                results.forEach(result => {
                    if (result.data) {
                        klineData[result.interval] = result.data;
                    }
                });
                
                return klineData;
            }
            
            calculateTechnicalAnalysis(klineData, config) {
                const analysis = {};
                
                Object.keys(klineData).forEach(interval => {
                    const data = klineData[interval];
                    if (!data || data.length === 0) {
                        analysis[interval] = null;
                        return;
                    }
                    
                    const closes = data.map(item => item.close);
                    const highs = data.map(item => item.high);
                    const lows = data.map(item => item.low);
                    
                    let smaLongPeriod;
                    if (interval === config.execution) smaLongPeriod = config.smaLongExecution;
                    else if (interval === config.tactical) smaLongPeriod = config.smaLongTactical;
                    else smaLongPeriod = config.smaLongStrategic;

                    analysis[interval] = {
                        currentPrice: closes[closes.length - 1],
                        smaShort: TechnicalIndicators.SMA(closes, config.smaShort),
                        smaLong: TechnicalIndicators.SMA(closes, smaLongPeriod),
                        macd: TechnicalIndicators.MACD(closes),
                        atr: TechnicalIndicators.ATR(highs, lows, closes),
                        closes
                    };
                });
                
                return analysis;
            }
            
            // [MODIFIED] 主机会评估流程
            evaluateOpportunity(analysis, config) {
                const executionData = analysis[config.execution];
                const tacticalData = analysis[config.tactical];
                const strategicData = analysis[config.strategic];
                
                if (!executionData || !tacticalData || !strategicData) {
                    return { hasOpportunity: false, signalType: 'none', error: '数据不足' };
                }
                
                const strategicTCM = this.evaluateTCM(strategicData);
                const tacticalTCM = this.evaluateTCM(tacticalData);
                const macdSignal = this.evaluateMACDSignal(executionData);
                
                let signalType = 'none';
                let hasOpportunity = false;
                
                if ((strategicTCM === 'bullish' || tacticalTCM === 'bullish') && 
                    (macdSignal === 'golden_cross' || macdSignal === 'bullish_momentum')) {
                    signalType = 'long';
                    hasOpportunity = true;
                } 
                else if ((strategicTCM === 'bearish' || tacticalTCM === 'bearish') && 
                          (macdSignal === 'death_cross' || macdSignal === 'bearish_momentum')) {
                    signalType = 'short';
                    hasOpportunity = true;
                }
                
                let spaceFilter = false, qualityFilter = false;
                let filters = {};
                // [NEW] 增加isHighQuality标志位
                let isHighQuality = false;

                if (hasOpportunity) {
                    filters = this.applyFilters(executionData, signalType);
                    spaceFilter = filters.spaceFilter;
                    qualityFilter = filters.qualityFilter;
                    
                    hasOpportunity = spaceFilter || qualityFilter;

                    // [NEW] 如果是常规机会，则进行高质量机会的二次筛选
                    if (hasOpportunity) {
                        isHighQuality = this.evaluateHighQualityOpportunity(analysis, config, signalType);
                    }
                }
                
                return {
                    hasOpportunity,
                    signalType,
                    isHighQuality, // [NEW] 返回高质量标志
                    strategicTCM,
                    tacticalTCM,
                    macdSignal,
                    spaceFilter,
                    qualityFilter,
                    riskReward: hasOpportunity ? filters.riskReward.toFixed(2) : '0.00',
                    entryPrice: hasOpportunity ? filters.entryPrice : 0,
                    stopLoss: hasOpportunity ? filters.stopLoss : 0,
                    takeProfit: hasOpportunity ? filters.takeProfit : 0,
                };
            }

            // [NEW] 全新的高质量机会评估方法
            evaluateHighQualityOpportunity(analysis, config, signalType) {
                const executionData = analysis[config.execution];
                const tacticalData = analysis[config.tactical];
                const strategicData = analysis[config.strategic];

                // 如果任何一个周期数据缺失，则不是高质量机会
                if (!executionData?.macd || !tacticalData?.macd || !strategicData?.macd || !executionData?.atr) {
                    return false;
                }
                
                // 只针对做多信号进行高质量筛选
                if (signalType === 'long') {
                    const executionSignal = this.evaluateMACDSignal(executionData);
                    const tacticalSignal = this.evaluateMACDSignal(tacticalData);

                    // 条件1: 执行周期（如15m）和战术周期（如1h）都刚刚形成金叉
                    const isCrossConcurrent = (executionSignal === 'golden_cross' && tacticalSignal === 'golden_cross');
                    if (!isCrossConcurrent) return false;

                    // 条件2: 价格在所有三个周期的短期均线之上
                    const isAboveAllMAs = executionData.currentPrice > executionData.smaShort &&
                                          tacticalData.currentPrice > tacticalData.smaShort &&
                                          strategicData.currentPrice > strategicData.smaShort;
                    if (!isAboveAllMAs) return false;

                    // 条件3: 价格没有上涨太多（与执行周期的短期均线距离小于0.75倍ATR）
                    const proximityToExecutionMA = (executionData.currentPrice - executionData.smaShort) < (0.75 * executionData.atr);
                    if (!proximityToExecutionMA) return false;

                    // 如果所有最严格的条件都满足，则这是一个高质量机会
                    return true;
                }

                // (未来可以补充高质量做空信号的逻辑)
                
                return false;
            }
            
            evaluateTCM(data) {
                if (!data || !data.currentPrice || !data.smaShort || !data.smaLong || !data.macd) {
                    return 'neutral';
                }
                
                const isBullish = data.currentPrice > data.smaShort && 
                                  data.currentPrice > data.smaLong &&
                                  data.macd.macd > 0;

                const isBearish = data.currentPrice < data.smaShort &&
                                  data.currentPrice < data.smaLong &&
                                  data.macd.macd < 0;

                if (isBullish) {
                    return 'bullish';
                } else if (isBearish) {
                    return 'bearish';
                } else {
                    return 'neutral';
                }
            }
            
            evaluateMACDSignal(data) {
                if (!data.macd) return 'none';
                
                const { macd, signal, prevMacd, prevSignal } = data.macd;
                
                const currentAbove = macd > signal;
                const prevAbove = prevMacd > prevSignal;
                
                if (currentAbove && !prevAbove) return 'golden_cross';
                if (!currentAbove && prevAbove) return 'death_cross';
                if (macd > 0 && currentAbove) return 'bullish_momentum';
                if (macd < 0 && !currentAbove) return 'bearish_momentum';
                
                return 'neutral';
            }
            
            applyFilters(executionData, signalType) {
                const { currentPrice, smaShort, atr } = executionData;
                
                if (!smaShort || !atr || atr === 0) {
                    return { spaceFilter: false, qualityFilter: false, riskReward: 0 };
                }
                
                const { entryPrice, stopLoss, takeProfit } = this.calculatePositionLevels(currentPrice, smaShort, atr, signalType);

                const stopDistance = Math.abs(entryPrice - stopLoss);
                if(stopDistance === 0) {
                    return { spaceFilter: false, qualityFilter: false, riskReward: 0, entryPrice, stopLoss, takeProfit };
                }

                const profitDistance = Math.abs(takeProfit - entryPrice);
                const spaceFilter = profitDistance >= (0.5 * atr);
                
                const qualityFilter = stopDistance <= (2.0 * atr);
                
                const riskReward = profitDistance / stopDistance;
                
                return { 
                    spaceFilter, 
                    qualityFilter, 
                    riskReward,
                    entryPrice,
                    stopLoss,
                    takeProfit
                };
            }

            calculatePositionLevels(currentPrice, sma60, atr, signalType) {
                let entryPrice, stopLoss, takeProfit;
                const riskMultiplier = 1.5;

                if (signalType === 'long') {
                    entryPrice = currentPrice;
                    stopLoss = currentPrice - (riskMultiplier * atr);
                    takeProfit = sma60; 
                    
                    if (takeProfit <= entryPrice) {
                        const riskAmount = entryPrice - stopLoss;
                        takeProfit = entryPrice + (2 * riskAmount);
                    }
                } else { // 'short'
                    entryPrice = currentPrice;
                    stopLoss = currentPrice + (riskMultiplier * atr);
                    takeProfit = sma60;
                    
                    if (takeProfit >= entryPrice) {
                        const riskAmount = stopLoss - entryPrice;
                        takeProfit = entryPrice - (2 * riskAmount);
                    }
                }
                
                return { entryPrice, stopLoss, takeProfit };
            }
            
            createBatches(array, batchSize) {
                const batches = [];
                for (let i = 0; i < array.length; i += batchSize) {
                    batches.push(array.slice(i, i + batchSize));
                }
                return batches;
            }
            
            updateProgress(progress, currentSymbol, processed) {
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('progressText').textContent = 
                    `扫描中... ${currentSymbol} (${processed}/${this.symbols.length})`;
                
                const elapsed = (Date.now() - this.startTime) / 1000;
                if (elapsed > 0) {
                    const speed = processed / elapsed;
                    document.getElementById('progressSpeed').textContent = `${speed.toFixed(1)} 个/秒`;
                }
            }
            
            hideAllResults() {
                ['15m', '1h', '4h'].forEach(timeframe => {
                    const container = document.getElementById(`results${timeframe}`);
                    container.querySelector('.results-table').style.display = 'none';
                    container.querySelector('.no-opportunities').style.display = 'block';
                });
                
                document.getElementById('summary').style.display = 'none';
                document.getElementById('performanceMetrics').style.display = 'none';
                document.getElementById('timeframeTabs').style.display = 'none';
            }
            
            displayAllResults() {
                ['15m', '1h', '4h'].forEach(timeframe => {
                    this.displayTimeframeResults(timeframe);
                    this.updateTimeframeCount(timeframe);
                });
            }
            
            // [MODIFIED] 更新UI显示，增加高质量信号的钻石图标
            displayTimeframeResults(timeframe) {
                const container = document.getElementById(`results${timeframe}`);
                const table = container.querySelector('.results-table');
                const tbody = container.querySelector('tbody');
                const noOpportunities = container.querySelector('.no-opportunities');
                
                const opportunities = this.opportunities[timeframe];
                
                tbody.innerHTML = '';
                
                if (opportunities.length === 0) {
                    table.style.display = 'none';
                    noOpportunities.style.display = 'block';
                    return;
                }
                
                opportunities.forEach(opp => {
                    const row = document.createElement('tr');
                    
                    const signalClass = opp.signalType === 'long' ? 'signal-long' : 'signal-short';
                    const changeClass = opp.change24h >= 0 ? 'positive' : 'negative';
                    
                    // [MODIFIED] 根据isHighQuality标志添加钻石图标
                    const highQualityIcon = opp.isHighQuality ? '💎 ' : '';
                    
                    row.innerHTML = `
                        <td><strong>${opp.symbol}</strong></td>
                        <td class="volume">${this.formatVolume(opp.volume)}</td>
                        <td>${this.formatPrice(opp.price)}</td>
                        <td class="${changeClass}">${opp.change24h > 0 ? '+' : ''}${opp.change24h.toFixed(2)}%</td>
                        <td class="${signalClass}">${highQualityIcon}${this.getSignalText(opp.signalType)}</td>
                        <td class="${this.getTCMClass(opp.strategicTCM)}">${this.getTCMText(opp.strategicTCM)}</td>
                        <td class="${this.getTCMClass(opp.tacticalTCM)}">${this.getTCMText(opp.tacticalTCM)}</td>
                        <td>${this.getMACDText(opp.macdSignal)}</td>
                        <td><strong>${this.formatPrice(opp.entryPrice)}</strong></td>
                        <td class="negative"><strong>${this.formatPrice(opp.stopLoss)}</strong></td>
                        <td class="positive"><strong>${this.formatPrice(opp.takeProfit)}</strong></td>
                        <td><strong class="${opp.riskReward >= 2 ? 'positive' : opp.riskReward >= 1.5 ? 'volume' : 'negative'}">1:${opp.riskReward}</strong></td>
                        <td>
                            <div class="filters-passed">
                                ${opp.spaceFilter ? '<span class="filter-badge filter-space">空间✓</span>' : ''}
                                ${opp.qualityFilter ? '<span class="filter-badge filter-quality">质量✓</span>' : ''}
                            </div>
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
                table.style.display = 'table';
                noOpportunities.style.display = 'none';
            }
            
            updateTimeframeCount(timeframe) {
                const count = this.opportunities[timeframe].length;
                document.getElementById(`count${timeframe}`).textContent = `(${count})`;
            }
            
            updateOverallSummary() {
                const allOpportunities = Object.values(this.opportunities).flat();
                const totalOpportunities = allOpportunities.length;
                const longSignals = allOpportunities.filter(o => o.signalType === 'long').length;
                const shortSignals = allOpportunities.filter(o => o.signalType === 'short').length;
                
                document.getElementById('totalScanned').textContent = this.symbols.length;
                document.getElementById('totalOpportunities').textContent = totalOpportunities;
                document.getElementById('longSignals').textContent = longSignals;
                document.getElementById('shortSignals').textContent = shortSignals;
                
                document.getElementById('summary').style.display = 'flex';
            }
            
            updatePerformanceMetrics() {
                const elapsed = (Date.now() - this.startTime) / 1000;
                const avgSpeed = elapsed > 0 ? this.processedCount / elapsed : 0;
                const successRate = this.processedCount > 0 ? (this.successCount / this.processedCount) * 100 : 0;
                
                document.getElementById('scanTime').textContent = `${elapsed.toFixed(1)}s`;
                document.getElementById('avgSpeed').textContent = `${avgSpeed.toFixed(1)}/s`;
                document.getElementById('successRate').textContent = `${successRate.toFixed(1)}%`;
                document.getElementById('apiCalls').textContent = this.apiCallCount;
                
                document.getElementById('performanceMetrics').style.display = 'flex';
            }
            
            formatVolume(volume) {
                if (volume >= 1e9) return (volume / 1e9).toFixed(1) + 'B';
                if (volume >= 1e6) return (volume / 1e6).toFixed(1) + 'M';
                if (volume >= 1e3) return (volume / 1e3).toFixed(1) + 'K';
                return volume.toFixed(0);
            }
            
            formatPrice(price) {
                if (price >= 1) return price.toFixed(4);
                if (price >= 0.01) return price.toFixed(6);
                return price.toPrecision(4);
            }
            
            getSignalText(signal) {
                return { 'long': '🚀 做多', 'short': '📉 做空' }[signal] || '-';
            }
            
            getTCMText(tcm) {
                return { 'bullish': '🟢 看涨', 'bearish': '🔴 看跌', 'neutral': '⚪ 中性' }[tcm] || '-';
            }
            
            getTCMClass(tcm) {
                return { 'bullish': 'tcm-bullish', 'bearish': 'tcm-bearish', 'neutral': 'tcm-neutral' }[tcm] || '';
            }
            
            getMACDText(macd) {
                return {
                    'golden_cross': '🌟 金叉',
                    'death_cross': '💀 死叉',
                    'bullish_momentum': '🔥 看涨',
                    'bearish_momentum': '❄️ 看跌',
                    'neutral': '⚪ 中性'
                }[macd] || '-';
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new MultiTimeframeScanner();
        });
    </script>
</body>
</html>
